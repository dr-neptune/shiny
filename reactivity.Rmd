# Reactivity

```{r}
library(tidyverse)
library(shiny)
```

In shiny we express our server logic using reactive programming. The key idea of reactive programming is that we specify a graph of dependencies so that when an input changes, all related outputs are automatically updated. 

# The Server Function

The server function is a bit more difficult to cover than the ui because each instance of the app needs to be independent from the other instances. This way if user A moves a slider, user B doesnt also see that same slider moving. 

Shiny achieves this independence by invoking the server function each time a new session starts. Server functions take 3 parameters which are handled by the shiny session: 

- input 
- output
- session 

## Input 

The input argument is a list like object which contains all the input data sent from the browser, named according to the input id.

If we have an input named "count", we can access it via input$count. The value will be dynamically updated by the browser. 

Unlike a typical list, input objects are read only. This means we can't update them within a function, like so

```{r}
server <- function(input, output, session) {
    input$count <- 10
}
```

This will cause an error. This is because the browser is the one source of truth for shiny. If we modify the value in R, we could introduce consistencies. There are functions like updateNumericInput that modify the value in the browser. These will be covered in chapter 7. 

input is also selective about what can read it. To read from input, you must be in a reactive context created by a function like renderText or reactive. This is an important constraint which allows outputs to automatically update when an input changes. 

## Output 

Output is also a list like object named according to the output id. The main difference is that we use it for sending output rather than receiving input. You always use the output object in concert with a render function

```{r}
ui <- fluidPage(
    textOutput("greeting")
)

server <- function(input, output, session) {
    output$greeting <- renderText("Hello, Human!")
}

shinyApp(ui, server)
```

The render function does two things: 

- it sets up a special reactive context that automatically tracks what inputs the output uses 
- it converts the output of your R code into HTML suitable for display on a web page

Like input, output is picky about how it is used. It will fail if 

- you forget the render function 
- you attempt to read from an output

# Reactive Programming

```{r}
ui <- fluidPage(
    textInput("name", "What's your name?"),
    textOutput("greeting"))

server <- function(input, output, session) {
    output$greeting <- renderText({
        paste0("Hello ", input$name, "!")})}

shinyApp(ui, server)
```

This is the big idea in shiny -- you dont need to tell an output when to update, because shiny automatically figures it out for you. Shiny performs the action given to it every time we update input$name. The app essentially provides shiny with recipes as opposed to commands. This makes shiny declarative as opposed to imperative. 

In **imperative** programming, we issue a command and it is carried out immediately. This is what we usually do when we write an analysis script in R or python.

In **declarative** programming, you express higher level goals or describe important constraints and rely on someone else to decide how or when to translate that into action. 

## Laziness 

Apps in shiny are lazy by default. This means that if your code contains errors, it will generally still run but it may not give you back what you wanted. If you are working on a shiny app and you can't figure out why your code won't run, double check that your ui and server functions are using the same identifiers. 

```{r}

ui <- fluidPage(
    textInput("name", "What's your name?"),
    textOutput("greeting"))

server <- function(input, output, session) {
    output$greeting <- renderText({
        paste0("Hello ", input$name, "!")})}

shinyApp(ui, server)

```

This is the big idea in shiny -- you dont need to tell an output when to update, because shiny automatically figures it out for you. Shiny performs the action given to it every time we update input$name. The app essentially provides shiny with recipes as opposed to commands. This makes shiny declarative as opposed to imperative. 

In **imperative** programming, we issue a command and it is carried out immediately. This is what we usually do when we write an analysis script in R or python.

In **declarative** programming, you express higher level goals or describe important constraints and rely on someone else to decide how or when to translate that into action. 

## Laziness 

Apps in shiny are lazy by default. This means that if your code contains errors, it will generally still run but it may not give you back what you wanted. If you are working on a shiny app and you can't figure out why your code won't run, double check that your ui and server functions are using the same identifiers. 

```{r}
ui <- fluidPage(
    textInput("name", "What's your name?"),
    textOutput("greeting"))

server <- function(input, output, session) {
    output$greeting <- renderText({
        paste0("Hello ", input$name, "!")})}

shinyApp(ui, server)
```

## The Reactive Graph 

Shiny is backed by a reactive graph which describes how inputs and outputs are handled. 

The reactive graph contains one symbol for every input and output, and we connect the input and output whenever the output accesses the input. 


#+DOWNLOADED: /tmp/screenshot.png @ 2020-01-04 17:16:05
[[file:screenshot_2020-01-04_17-16-05.png]]

This tells us that greeting will be need to be recomputed whenever name is changed. 

There is also an addon called reactlog which will draw the graph for you and show a breakdown over time. 

(reactlog)[https://rstudio.github.io/reactlog/articles/reactlog.html]

Here is the hello reactlog program. Once the app is run, launch reactlog by pressing ctrl F3

```{r}
options(shiny.reactlog = TRUE)

library(reactlog)
library(plotly)

ui <- fluidPage(
    selectInput("var", "Choose a variable.", choices = names(diamonds)),
    plotlyOutput("plot"))

server <- function(input, output, session) {
    output$plot <- renderPlotly({
        plot_ly(x = diamonds[[input$var]])})}

shinyApp(ui, server)
```

There is one other component that will arise in the reactive graph: the reactive expression. For now we can think of them as a tool that reduces duplication in our reactive code by introducting additional nodes into the reactive graph. 

We dont need a reactive expression in this simple app, but here is one anyways to illustrate:

```{r}
server <- function(input, output, session) {
    text <- reactive(paste0("Hello ", input$name, "!"))
    output$greeting <- renderText(text())
}
```


#+DOWNLOADED: /tmp/screenshot.png @ 2020-01-04 17:38:34
[[file:screenshot_2020-01-04_17-38-34.png]]

## Execution Order 

The order in which your code is run is determined by the reactive graph. 

For example, we could switch around the code in the server function above

```{r}
server <- function(input, output, session) {
    output$greeting <- renderText(text())
    text <- reactive(paste0("Hello ", input$name, "!"))}
```

In a normal code environment this wouldnt work. Shiny is lazy, so the code is only ran when the session starts, after text has been created. 

## Exercises

1. 

```{r}
server1 <- function(input, output, session) {
    c <- reactive(input$a + input$b)
    e <- reactive(c() + input$d)
    output$f <- renderText(e())
}
```


#+DOWNLOADED: /tmp/screenshot.png @ 2020-01-04 22:13:42
[[file:screenshot_2020-01-04_22-13-42.png]]

